var x=(M,d,u)=>{"use strict";u.r(d),u.d(d,{BloomFilter:()=>g});let f={32:BigInt(16777619),64:BigInt(1099511628211),128:BigInt(3094850098213451e11),256:BigInt(37414441915671115e34),512:BigInt(3583591587484487e88),1024:BigInt(5016456510113119e189)},w={32:BigInt(2166136261),64:BigInt(0xcbf29ce484222000),128:BigInt(14406626329776981e22),256:BigInt(10002925795805258e61),512:BigInt(965930312949667e139),1024:BigInt(1419779506494762e271)};function B(h,{size:t=32,seed:e=0}={}){if(!f[t])throw Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");let r=w[t]^BigInt(e),i=f[t],a=!1;for(let n=0;n<h.length;n++){let s=h.charCodeAt(n);s>127&&!a&&(s=(h=unescape(encodeURIComponent(h))).charCodeAt(n),a=!0),r^=BigInt(s),r=BigInt.asUintN(t,r*i)}return r}function c(h){let t=Number(h).toString(16);return t.length%4!=0&&(t="0".repeat(4-t.length%4)+t),t}function o(){return 78187493520}class y{doubleHashing(t,e,r,i){return Math.abs((e+t*r+Math.floor((t**3-t)/6))%i)}getDistinctIndexes(t,e,r,i){i===void 0&&(i=o());let a=0,n=new Set,s=this.hashTwice(t,i);for(;n.size<r;){let m=s.first%e;n.has(m)||n.add(m),s.first=(s.first+s.second)%e,s.second=(s.second+a)%e,++a>e&&(i++,s=this.hashTwice(t,i))}return[...n.values()]}getIndexes(t,e,r,i){i===void 0&&(i=o());let a=[],n=this.hashTwice(t,i);for(let s=0;s<r;s++)a.push(this.doubleHashing(s,n.first,n.second,e));return a}serialize(t,e){return e||(e=o()),Number(B(t,{seed:e}))}hashTwice(t,e){return e===void 0&&(e=o()),{first:this.serialize(t,e+1),second:this.serialize(t,e+2)}}hashTwiceAsString(t,e){let{first:r,second:i}=this.hashTwice(t,e);return{first:c(r),second:c(i)}}hashTwiceIntAndString(t,e){e===void 0&&(e=o());let r=this.hashIntAndString(t,e+1),i=this.hashIntAndString(t,e+2);return{int:{first:r.int,second:i.int},string:{first:r.string,second:i.string}}}hashAsInt(t,e){return e===void 0&&(e=o()),this.serialize(t,e)}hashIntAndString(t,e){let r=this.hashAsInt(t,e);return{int:r,string:c(r)}}}function _(){return crypto.getRandomValues(new Uint32Array(1))[0]}function I(){return{int32:_,quick:_}}class p{get seed(){return this._seed}set seed(t){this._seed=t,this._rng=I()}get random(){return this._rng}nextInt32(){return this._rng.int32()}saveAsJSON(){throw Error("not-implemented")}static fromJSON(t){throw Error("not-implemented")}constructor(){this._seed=o(),this._rng=I(),this._hashing=new y}}var z=u(4993);class l{has(t){return(this.array[Math.floor(t/8)]&1<<t%8)!=0}add(t){let e=Math.floor(t/8);this.array[e]=this.array[e]|1<<t%8}max(){for(let t=this.array.length-1;t>=0;t--){let e=this.array[t];if(e)return l.highBit(e)+8*t}return 0}bitCount(){let t=0;for(let e=0;e<this.array.length;e++)t+=l.countBits(this.array[e]);return t}equals(t){if(t.size!==this.size)return!1;for(let e=0;e<this.array.length;e++)if(this.array[e]!==t.array[e])return!1;return!0}export(){return{size:this.size,content:(0,z.encode)(this.array)}}static import(t){if(typeof t.size!="number")throw Error("BitSet missing size");if(typeof t.content!="string")throw Error("BitSet: missing content");let e=new l(t.size),r=(0,z.decode)(t.content);return e.array=new Uint8Array(r),e}static highBit(t){let e=7,r=128;for(;e>=0&&(r&t)!==r;)r>>>=1,e--;return e}static countBits(t){let e=1&t;for(;t!==0;)t>>>=1,e+=1&t;return e}constructor(t){let e=8-t%8;this.size=t+([0,8].includes(e)?0:e),this.array=new Uint8Array(Math.ceil(this.size/8))}}function b(h,t){return Math.ceil(-(h*Math.log(t)/Math.pow(Math.log(2),2)))}function A(h,t){return Math.ceil(h/t*Math.log(2))}class g extends p{static create(t,e){let r=b(t,e),i=A(r,t);return new this(r,i)}static from(t,e,r){let i=Array.from(t),a=g.create(i.length,e);return typeof r=="number"&&(a.seed=r),i.forEach(n=>a.add(n)),a}get size(){return this._size}get length(){return this._filter.bitCount()}add(t){let e=this._hashing.getIndexes(t,this._size,this._nbHashes,this.seed);for(let r=0;r<e.length;r++)this._filter.add(e[r])}has(t){let e=this._hashing.getIndexes(t,this._size,this._nbHashes,this.seed);for(let r=0;r<e.length;r++)if(!this._filter.has(e[r]))return!1;return!0}rate(){return Math.pow(1-Math.exp(-this.length/this._size),this._nbHashes)}equals(t){return this._size===t._size&&this._nbHashes===t._nbHashes&&this._filter.equals(t._filter)}export(){return{bitset:this._filter.export(),hashes:this._nbHashes,size:this._size}}import(t){this._filter=l.import(t.bitset)}constructor(t,e){if(super(),e<1)throw Error(`A BloomFilter cannot uses less than one hash function, while you tried to use ${e}.`);this._size=t,this._nbHashes=e,this._filter=new l(t)}}};export{x as default};
